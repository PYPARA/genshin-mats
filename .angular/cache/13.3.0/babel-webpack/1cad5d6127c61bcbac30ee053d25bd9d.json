{"ast":null,"code":"/*!\r\n LZ-UTF8 v0.6.1\r\n\r\n Copyright (c) 2021, Rotem Dan\r\n Released under the MIT license.\r\n\r\n Build date: 2022-03-03 \r\n\r\n Please report any issue at https://github.com/rotemdan/lzutf8.js/issues\r\n*/\nvar LZUTF8;\n\n(function (LZUTF8) {\n  LZUTF8.runningInNodeJS = function () {\n    return typeof process === \"object\" && typeof process.versions === \"object\" && typeof process.versions.node === \"string\";\n  };\n\n  LZUTF8.runningInMainNodeJSModule = function () {\n    return LZUTF8.runningInNodeJS() && require.main === module;\n  };\n\n  LZUTF8.commonJSAvailable = function () {\n    return typeof module === \"object\" && typeof module.exports === \"object\";\n  };\n\n  LZUTF8.runningInWebWorker = function () {\n    return typeof window === \"undefined\" && typeof self === \"object\" && typeof self.addEventListener === \"function\" && typeof self.close === \"function\";\n  };\n\n  LZUTF8.runningInNodeChildProcess = function () {\n    return LZUTF8.runningInNodeJS() && typeof process.send === \"function\";\n  };\n\n  LZUTF8.runningInNullOrigin = function () {\n    if (typeof window !== \"object\" || typeof window.location !== \"object\" || typeof document !== \"object\") return false;\n    return document.location.protocol !== 'http:' && document.location.protocol !== 'https:';\n  };\n\n  LZUTF8.webWorkersAvailable = function () {\n    if (typeof Worker !== \"function\" || LZUTF8.runningInNullOrigin()) return false;\n    if (LZUTF8.runningInNodeJS()) return false;\n    if (navigator && navigator.userAgent && navigator.userAgent.indexOf(\"Android 4.3\") >= 0) return false;\n    return true;\n  };\n\n  LZUTF8.log = function (message, appendToDocument) {\n    if (appendToDocument === void 0) {\n      appendToDocument = false;\n    }\n\n    if (typeof console !== \"object\") return;\n    console.log(message);\n    if (appendToDocument && typeof document == \"object\") document.body.innerHTML += message + \"<br/>\";\n  };\n\n  LZUTF8.createErrorMessage = function (exception, title) {\n    if (title === void 0) {\n      title = \"Unhandled exception\";\n    }\n\n    if (exception == null) return title;\n    title += \": \";\n\n    if (typeof exception.content === \"object\") {\n      if (LZUTF8.runningInNodeJS()) {\n        return title + exception.content.stack;\n      } else {\n        var exceptionJSON = JSON.stringify(exception.content);\n        if (exceptionJSON !== \"{}\") return title + exceptionJSON;else return title + exception.content;\n      }\n    } else if (typeof exception.content === \"string\") {\n      return title + exception.content;\n    } else {\n      return title + exception;\n    }\n  };\n\n  LZUTF8.printExceptionAndStackTraceToConsole = function (exception, title) {\n    if (title === void 0) {\n      title = \"Unhandled exception\";\n    }\n\n    LZUTF8.log(LZUTF8.createErrorMessage(exception, title));\n  };\n\n  LZUTF8.getGlobalObject = function () {\n    if (typeof global === \"object\") return global;else if (typeof window === \"object\") return window;else if (typeof self === \"object\") return self;else return {};\n  };\n\n  LZUTF8.toString = Object.prototype.toString;\n  if (LZUTF8.commonJSAvailable()) module.exports = LZUTF8;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar IE10SubarrayBugPatcher;\n\n(function (IE10SubarrayBugPatcher) {\n  if (typeof Uint8Array === \"function\" && new Uint8Array(1).subarray(1).byteLength !== 0) {\n    var subarray = function (start, end) {\n      var clamp = function (v, min, max) {\n        return v < min ? min : v > max ? max : v;\n      };\n\n      start = start | 0;\n      end = end | 0;\n      if (arguments.length < 1) start = 0;\n      if (arguments.length < 2) end = this.length;\n      if (start < 0) start = this.length + start;\n      if (end < 0) end = this.length + end;\n      start = clamp(start, 0, this.length);\n      end = clamp(end, 0, this.length);\n      var len = end - start;\n      if (len < 0) len = 0;\n      return new this.constructor(this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n    };\n\n    var types = ['Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array'];\n    var globalObject = void 0;\n    if (typeof window === \"object\") globalObject = window;else if (typeof self === \"object\") globalObject = self;\n\n    if (globalObject !== undefined) {\n      for (var i = 0; i < types.length; i++) {\n        if (globalObject[types[i]]) globalObject[types[i]].prototype.subarray = subarray;\n      }\n    }\n  }\n})(IE10SubarrayBugPatcher || (IE10SubarrayBugPatcher = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var AsyncCompressor = function () {\n    function AsyncCompressor() {}\n\n    AsyncCompressor.compressAsync = function (input, options, callback) {\n      var timer = new LZUTF8.Timer();\n      var compressor = new LZUTF8.Compressor();\n      if (!callback) throw new TypeError(\"compressAsync: No callback argument given\");\n\n      if (typeof input === \"string\") {\n        input = LZUTF8.encodeUTF8(input);\n      } else if (input == null || !(input instanceof Uint8Array)) {\n        callback(undefined, new TypeError(\"compressAsync: Invalid input argument, only 'string' and 'Uint8Array' are supported\"));\n        return;\n      }\n\n      var sourceBlocks = LZUTF8.ArrayTools.splitByteArray(input, options.blockSize);\n      var compressedBlocks = [];\n\n      var compressBlocksStartingAt = function (index) {\n        if (index < sourceBlocks.length) {\n          var compressedBlock = void 0;\n\n          try {\n            compressedBlock = compressor.compressBlock(sourceBlocks[index]);\n          } catch (e) {\n            callback(undefined, e);\n            return;\n          }\n\n          compressedBlocks.push(compressedBlock);\n\n          if (timer.getElapsedTime() <= 20) {\n            compressBlocksStartingAt(index + 1);\n          } else {\n            LZUTF8.enqueueImmediate(function () {\n              return compressBlocksStartingAt(index + 1);\n            });\n            timer.restart();\n          }\n        } else {\n          var joinedCompressedBlocks_1 = LZUTF8.ArrayTools.concatUint8Arrays(compressedBlocks);\n          LZUTF8.enqueueImmediate(function () {\n            var result;\n\n            try {\n              result = LZUTF8.CompressionCommon.encodeCompressedBytes(joinedCompressedBlocks_1, options.outputEncoding);\n            } catch (e) {\n              callback(undefined, e);\n              return;\n            }\n\n            LZUTF8.enqueueImmediate(function () {\n              return callback(result);\n            });\n          });\n        }\n      };\n\n      LZUTF8.enqueueImmediate(function () {\n        return compressBlocksStartingAt(0);\n      });\n    };\n\n    AsyncCompressor.createCompressionStream = function () {\n      var compressor = new LZUTF8.Compressor();\n\n      var NodeStream = require(\"readable-stream\");\n\n      var compressionStream = new NodeStream.Transform({\n        decodeStrings: true,\n        highWaterMark: 65536\n      });\n\n      compressionStream._transform = function (data, encoding, done) {\n        var buffer;\n\n        try {\n          buffer = LZUTF8.BufferTools.uint8ArrayToBuffer(compressor.compressBlock(LZUTF8.BufferTools.bufferToUint8Array(data)));\n        } catch (e) {\n          compressionStream.emit(\"error\", e);\n          return;\n        }\n\n        compressionStream.push(buffer);\n        done();\n      };\n\n      return compressionStream;\n    };\n\n    return AsyncCompressor;\n  }();\n\n  LZUTF8.AsyncCompressor = AsyncCompressor;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var AsyncDecompressor = function () {\n    function AsyncDecompressor() {}\n\n    AsyncDecompressor.decompressAsync = function (input, options, callback) {\n      if (!callback) throw new TypeError(\"decompressAsync: No callback argument given\");\n      var timer = new LZUTF8.Timer();\n\n      try {\n        input = LZUTF8.CompressionCommon.decodeCompressedBytes(input, options.inputEncoding);\n      } catch (e) {\n        callback(undefined, e);\n        return;\n      }\n\n      var decompressor = new LZUTF8.Decompressor();\n      var sourceBlocks = LZUTF8.ArrayTools.splitByteArray(input, options.blockSize);\n      var decompressedBlocks = [];\n\n      var decompressBlocksStartingAt = function (index) {\n        if (index < sourceBlocks.length) {\n          var decompressedBlock = void 0;\n\n          try {\n            decompressedBlock = decompressor.decompressBlock(sourceBlocks[index]);\n          } catch (e) {\n            callback(undefined, e);\n            return;\n          }\n\n          decompressedBlocks.push(decompressedBlock);\n\n          if (timer.getElapsedTime() <= 20) {\n            decompressBlocksStartingAt(index + 1);\n          } else {\n            LZUTF8.enqueueImmediate(function () {\n              return decompressBlocksStartingAt(index + 1);\n            });\n            timer.restart();\n          }\n        } else {\n          var joinedDecompressedBlocks_1 = LZUTF8.ArrayTools.concatUint8Arrays(decompressedBlocks);\n          LZUTF8.enqueueImmediate(function () {\n            var result;\n\n            try {\n              result = LZUTF8.CompressionCommon.encodeDecompressedBytes(joinedDecompressedBlocks_1, options.outputEncoding);\n            } catch (e) {\n              callback(undefined, e);\n              return;\n            }\n\n            LZUTF8.enqueueImmediate(function () {\n              return callback(result);\n            });\n          });\n        }\n      };\n\n      LZUTF8.enqueueImmediate(function () {\n        return decompressBlocksStartingAt(0);\n      });\n    };\n\n    AsyncDecompressor.createDecompressionStream = function () {\n      var decompressor = new LZUTF8.Decompressor();\n\n      var NodeStream = require(\"readable-stream\");\n\n      var decompressionStream = new NodeStream.Transform({\n        decodeStrings: true,\n        highWaterMark: 65536\n      });\n\n      decompressionStream._transform = function (data, encoding, done) {\n        var buffer;\n\n        try {\n          buffer = LZUTF8.BufferTools.uint8ArrayToBuffer(decompressor.decompressBlock(LZUTF8.BufferTools.bufferToUint8Array(data)));\n        } catch (e) {\n          decompressionStream.emit(\"error\", e);\n          return;\n        }\n\n        decompressionStream.push(buffer);\n        done();\n      };\n\n      return decompressionStream;\n    };\n\n    return AsyncDecompressor;\n  }();\n\n  LZUTF8.AsyncDecompressor = AsyncDecompressor;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var WebWorker;\n\n  (function (WebWorker) {\n    WebWorker.compressAsync = function (input, options, callback) {\n      if (options.inputEncoding == \"ByteArray\") {\n        if (!(input instanceof Uint8Array)) {\n          callback(undefined, new TypeError(\"compressAsync: input is not a Uint8Array\"));\n          return;\n        }\n      }\n\n      var request = {\n        token: Math.random().toString(),\n        type: \"compress\",\n        data: input,\n        inputEncoding: options.inputEncoding,\n        outputEncoding: options.outputEncoding\n      };\n\n      var responseListener = function (e) {\n        var response = e.data;\n        if (!response || response.token != request.token) return;\n        WebWorker.globalWorker.removeEventListener(\"message\", responseListener);\n        if (response.type == \"error\") callback(undefined, new Error(response.error));else callback(response.data);\n      };\n\n      WebWorker.globalWorker.addEventListener(\"message\", responseListener);\n      WebWorker.globalWorker.postMessage(request, []);\n    };\n\n    WebWorker.decompressAsync = function (input, options, callback) {\n      var request = {\n        token: Math.random().toString(),\n        type: \"decompress\",\n        data: input,\n        inputEncoding: options.inputEncoding,\n        outputEncoding: options.outputEncoding\n      };\n\n      var responseListener = function (e) {\n        var response = e.data;\n        if (!response || response.token != request.token) return;\n        WebWorker.globalWorker.removeEventListener(\"message\", responseListener);\n        if (response.type == \"error\") callback(undefined, new Error(response.error));else callback(response.data);\n      };\n\n      WebWorker.globalWorker.addEventListener(\"message\", responseListener);\n      WebWorker.globalWorker.postMessage(request, []);\n    };\n\n    WebWorker.installWebWorkerIfNeeded = function () {\n      if (typeof self == \"object\" && self.document === undefined && self.addEventListener != undefined) {\n        self.addEventListener(\"message\", function (e) {\n          var request = e.data;\n\n          if (request.type == \"compress\") {\n            var compressedData = void 0;\n\n            try {\n              compressedData = LZUTF8.compress(request.data, {\n                outputEncoding: request.outputEncoding\n              });\n            } catch (e) {\n              self.postMessage({\n                token: request.token,\n                type: \"error\",\n                error: LZUTF8.createErrorMessage(e)\n              }, []);\n              return;\n            }\n\n            var response = {\n              token: request.token,\n              type: \"compressionResult\",\n              data: compressedData,\n              encoding: request.outputEncoding\n            };\n            if (response.data instanceof Uint8Array && navigator.appVersion.indexOf(\"MSIE 10\") === -1) self.postMessage(response, [response.data.buffer]);else self.postMessage(response, []);\n          } else if (request.type == \"decompress\") {\n            var decompressedData = void 0;\n\n            try {\n              decompressedData = LZUTF8.decompress(request.data, {\n                inputEncoding: request.inputEncoding,\n                outputEncoding: request.outputEncoding\n              });\n            } catch (e) {\n              self.postMessage({\n                token: request.token,\n                type: \"error\",\n                error: LZUTF8.createErrorMessage(e)\n              }, []);\n              return;\n            }\n\n            var response = {\n              token: request.token,\n              type: \"decompressionResult\",\n              data: decompressedData,\n              encoding: request.outputEncoding\n            };\n            if (response.data instanceof Uint8Array && navigator.appVersion.indexOf(\"MSIE 10\") === -1) self.postMessage(response, [response.data.buffer]);else self.postMessage(response, []);\n          }\n        });\n        self.addEventListener(\"error\", function (e) {\n          LZUTF8.log(LZUTF8.createErrorMessage(e.error, \"Unexpected LZUTF8 WebWorker exception\"));\n        });\n      }\n    };\n\n    WebWorker.createGlobalWorkerIfNeeded = function () {\n      if (WebWorker.globalWorker) return true;\n      if (!LZUTF8.webWorkersAvailable()) return false;\n\n      if (!WebWorker.scriptURI && typeof document === \"object\") {\n        var scriptElement = document.getElementById(\"lzutf8\");\n        if (scriptElement != null) WebWorker.scriptURI = scriptElement.getAttribute(\"src\") || undefined;\n      }\n\n      if (WebWorker.scriptURI) {\n        WebWorker.globalWorker = new Worker(WebWorker.scriptURI);\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    WebWorker.terminate = function () {\n      if (WebWorker.globalWorker) {\n        WebWorker.globalWorker.terminate();\n        WebWorker.globalWorker = undefined;\n      }\n    };\n  })(WebWorker = LZUTF8.WebWorker || (LZUTF8.WebWorker = {}));\n\n  WebWorker.installWebWorkerIfNeeded();\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var ArraySegment = function () {\n    function ArraySegment(container, startPosition, length) {\n      this.container = container;\n      this.startPosition = startPosition;\n      this.length = length;\n    }\n\n    ArraySegment.prototype.get = function (index) {\n      return this.container[this.startPosition + index];\n    };\n\n    ArraySegment.prototype.getInReversedOrder = function (reverseIndex) {\n      return this.container[this.startPosition + this.length - 1 - reverseIndex];\n    };\n\n    ArraySegment.prototype.set = function (index, value) {\n      this.container[this.startPosition + index] = value;\n    };\n\n    return ArraySegment;\n  }();\n\n  LZUTF8.ArraySegment = ArraySegment;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var ArrayTools;\n\n  (function (ArrayTools) {\n    ArrayTools.copyElements = function (source, sourceIndex, destination, destinationIndex, count) {\n      while (count--) destination[destinationIndex++] = source[sourceIndex++];\n    };\n\n    ArrayTools.zeroElements = function (collection, index, count) {\n      while (count--) collection[index++] = 0;\n    };\n\n    ArrayTools.countNonzeroValuesInArray = function (array) {\n      var result = 0;\n\n      for (var i = 0; i < array.length; i++) if (array[i]) result++;\n\n      return result;\n    };\n\n    ArrayTools.truncateStartingElements = function (array, truncatedLength) {\n      if (array.length <= truncatedLength) throw new RangeError(\"truncateStartingElements: Requested length should be smaller than array length\");\n      var sourcePosition = array.length - truncatedLength;\n\n      for (var i = 0; i < truncatedLength; i++) array[i] = array[sourcePosition + i];\n\n      array.length = truncatedLength;\n    };\n\n    ArrayTools.doubleByteArrayCapacity = function (array) {\n      var newArray = new Uint8Array(array.length * 2);\n      newArray.set(array);\n      return newArray;\n    };\n\n    ArrayTools.concatUint8Arrays = function (arrays) {\n      var totalLength = 0;\n\n      for (var _i = 0, arrays_1 = arrays; _i < arrays_1.length; _i++) {\n        var array = arrays_1[_i];\n        totalLength += array.length;\n      }\n\n      var result = new Uint8Array(totalLength);\n      var offset = 0;\n\n      for (var _a = 0, arrays_2 = arrays; _a < arrays_2.length; _a++) {\n        var array = arrays_2[_a];\n        result.set(array, offset);\n        offset += array.length;\n      }\n\n      return result;\n    };\n\n    ArrayTools.splitByteArray = function (byteArray, maxPartLength) {\n      var result = [];\n\n      for (var offset = 0; offset < byteArray.length;) {\n        var blockLength = Math.min(maxPartLength, byteArray.length - offset);\n        result.push(byteArray.subarray(offset, offset + blockLength));\n        offset += blockLength;\n      }\n\n      return result;\n    };\n  })(ArrayTools = LZUTF8.ArrayTools || (LZUTF8.ArrayTools = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var BufferTools;\n\n  (function (BufferTools) {\n    BufferTools.convertToUint8ArrayIfNeeded = function (input) {\n      if (typeof Buffer === \"function\" && Buffer.isBuffer(input)) return BufferTools.bufferToUint8Array(input);else return input;\n    };\n\n    BufferTools.uint8ArrayToBuffer = function (arr) {\n      if (Buffer.prototype instanceof Uint8Array) {\n        var arrClone = new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n        Object[\"setPrototypeOf\"](arrClone, Buffer.prototype);\n        return arrClone;\n      } else {\n        var len = arr.length;\n        var buf = new Buffer(len);\n\n        for (var i = 0; i < len; i++) buf[i] = arr[i];\n\n        return buf;\n      }\n    };\n\n    BufferTools.bufferToUint8Array = function (buf) {\n      if (Buffer.prototype instanceof Uint8Array) {\n        return new Uint8Array(buf[\"buffer\"], buf[\"byteOffset\"], buf[\"byteLength\"]);\n      } else {\n        var len = buf.length;\n        var arr = new Uint8Array(len);\n\n        for (var i = 0; i < len; i++) arr[i] = buf[i];\n\n        return arr;\n      }\n    };\n  })(BufferTools = LZUTF8.BufferTools || (LZUTF8.BufferTools = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var CompressionCommon;\n\n  (function (CompressionCommon) {\n    CompressionCommon.getCroppedBuffer = function (buffer, cropStartOffset, cropLength, additionalCapacity) {\n      if (additionalCapacity === void 0) {\n        additionalCapacity = 0;\n      }\n\n      var croppedBuffer = new Uint8Array(cropLength + additionalCapacity);\n      croppedBuffer.set(buffer.subarray(cropStartOffset, cropStartOffset + cropLength));\n      return croppedBuffer;\n    };\n\n    CompressionCommon.getCroppedAndAppendedByteArray = function (bytes, cropStartOffset, cropLength, byteArrayToAppend) {\n      return LZUTF8.ArrayTools.concatUint8Arrays([bytes.subarray(cropStartOffset, cropStartOffset + cropLength), byteArrayToAppend]);\n    };\n\n    CompressionCommon.detectCompressionSourceEncoding = function (input) {\n      if (input == null) throw new TypeError(\"detectCompressionSourceEncoding: input is null or undefined\");\n      if (typeof input === \"string\") return \"String\";else if (input instanceof Uint8Array || typeof Buffer === \"function\" && Buffer.isBuffer(input)) return \"ByteArray\";else throw new TypeError(\"detectCompressionSourceEncoding: input must be of type 'string', 'Uint8Array' or 'Buffer'\");\n    };\n\n    CompressionCommon.encodeCompressedBytes = function (compressedBytes, outputEncoding) {\n      switch (outputEncoding) {\n        case \"ByteArray\":\n          return compressedBytes;\n\n        case \"Buffer\":\n          return LZUTF8.BufferTools.uint8ArrayToBuffer(compressedBytes);\n\n        case \"Base64\":\n          return LZUTF8.encodeBase64(compressedBytes);\n\n        case \"BinaryString\":\n          return LZUTF8.encodeBinaryString(compressedBytes);\n\n        case \"StorageBinaryString\":\n          return LZUTF8.encodeStorageBinaryString(compressedBytes);\n\n        default:\n          throw new TypeError(\"encodeCompressedBytes: invalid output encoding requested\");\n      }\n    };\n\n    CompressionCommon.decodeCompressedBytes = function (compressedData, inputEncoding) {\n      if (inputEncoding == null) throw new TypeError(\"decodeCompressedData: Input is null or undefined\");\n\n      switch (inputEncoding) {\n        case \"ByteArray\":\n        case \"Buffer\":\n          var normalizedBytes = LZUTF8.BufferTools.convertToUint8ArrayIfNeeded(compressedData);\n          if (!(normalizedBytes instanceof Uint8Array)) throw new TypeError(\"decodeCompressedData: 'ByteArray' or 'Buffer' input type was specified but input is not a Uint8Array or Buffer\");\n          return normalizedBytes;\n\n        case \"Base64\":\n          if (typeof compressedData !== \"string\") throw new TypeError(\"decodeCompressedData: 'Base64' input type was specified but input is not a string\");\n          return LZUTF8.decodeBase64(compressedData);\n\n        case \"BinaryString\":\n          if (typeof compressedData !== \"string\") throw new TypeError(\"decodeCompressedData: 'BinaryString' input type was specified but input is not a string\");\n          return LZUTF8.decodeBinaryString(compressedData);\n\n        case \"StorageBinaryString\":\n          if (typeof compressedData !== \"string\") throw new TypeError(\"decodeCompressedData: 'StorageBinaryString' input type was specified but input is not a string\");\n          return LZUTF8.decodeStorageBinaryString(compressedData);\n\n        default:\n          throw new TypeError(\"decodeCompressedData: invalid input encoding requested: '\".concat(inputEncoding, \"'\"));\n      }\n    };\n\n    CompressionCommon.encodeDecompressedBytes = function (decompressedBytes, outputEncoding) {\n      switch (outputEncoding) {\n        case \"String\":\n          return LZUTF8.decodeUTF8(decompressedBytes);\n\n        case \"ByteArray\":\n          return decompressedBytes;\n\n        case \"Buffer\":\n          if (typeof Buffer !== \"function\") throw new TypeError(\"encodeDecompressedBytes: a 'Buffer' type was specified but is not supported at the current envirnment\");\n          return LZUTF8.BufferTools.uint8ArrayToBuffer(decompressedBytes);\n\n        default:\n          throw new TypeError(\"encodeDecompressedBytes: invalid output encoding requested\");\n      }\n    };\n  })(CompressionCommon = LZUTF8.CompressionCommon || (LZUTF8.CompressionCommon = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var EventLoop;\n\n  (function (EventLoop) {\n    var queuedFunctions = [];\n    var asyncFlushFunc;\n\n    EventLoop.enqueueImmediate = function (func) {\n      queuedFunctions.push(func);\n      if (queuedFunctions.length === 1) asyncFlushFunc();\n    };\n\n    EventLoop.initializeScheduler = function () {\n      var flush = function () {\n        for (var _i = 0, queuedFunctions_1 = queuedFunctions; _i < queuedFunctions_1.length; _i++) {\n          var func = queuedFunctions_1[_i];\n\n          try {\n            func.call(undefined);\n          } catch (exception) {\n            LZUTF8.printExceptionAndStackTraceToConsole(exception, \"enqueueImmediate exception\");\n          }\n        }\n\n        queuedFunctions.length = 0;\n      };\n\n      if (LZUTF8.runningInNodeJS()) {\n        asyncFlushFunc = function () {\n          return setImmediate(function () {\n            return flush();\n          });\n        };\n      }\n\n      if (typeof window === \"object\" && typeof window.addEventListener === \"function\" && typeof window.postMessage === \"function\") {\n        var token_1 = \"enqueueImmediate-\" + Math.random().toString();\n        window.addEventListener(\"message\", function (event) {\n          if (event.data === token_1) flush();\n        });\n        var targetOrigin_1;\n        if (LZUTF8.runningInNullOrigin()) targetOrigin_1 = '*';else targetOrigin_1 = window.location.href;\n\n        asyncFlushFunc = function () {\n          return window.postMessage(token_1, targetOrigin_1);\n        };\n      } else if (typeof MessageChannel === \"function\" && typeof MessagePort === \"function\") {\n        var channel_1 = new MessageChannel();\n\n        channel_1.port1.onmessage = function () {\n          return flush();\n        };\n\n        asyncFlushFunc = function () {\n          return channel_1.port2.postMessage(0);\n        };\n      } else {\n        asyncFlushFunc = function () {\n          return setTimeout(function () {\n            return flush();\n          }, 0);\n        };\n      }\n    };\n\n    EventLoop.initializeScheduler();\n  })(EventLoop = LZUTF8.EventLoop || (LZUTF8.EventLoop = {}));\n\n  LZUTF8.enqueueImmediate = function (func) {\n    return EventLoop.enqueueImmediate(func);\n  };\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var ObjectTools;\n\n  (function (ObjectTools) {\n    ObjectTools.override = function (obj, newPropertyValues) {\n      return ObjectTools.extend(obj, newPropertyValues);\n    };\n\n    ObjectTools.extend = function (obj, newProperties) {\n      if (obj == null) throw new TypeError(\"obj is null or undefined\");\n      if (typeof obj !== \"object\") throw new TypeError(\"obj is not an object\");\n      if (newProperties == null) newProperties = {};\n      if (typeof newProperties !== \"object\") throw new TypeError(\"newProperties is not an object\");\n\n      if (newProperties != null) {\n        for (var property in newProperties) obj[property] = newProperties[property];\n      }\n\n      return obj;\n    };\n  })(ObjectTools = LZUTF8.ObjectTools || (LZUTF8.ObjectTools = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  LZUTF8.getRandomIntegerInRange = function (low, high) {\n    return low + Math.floor(Math.random() * (high - low));\n  };\n\n  LZUTF8.getRandomUTF16StringOfLength = function (length) {\n    var randomString = \"\";\n\n    for (var i = 0; i < length; i++) {\n      var randomCodePoint = void 0;\n\n      do {\n        randomCodePoint = LZUTF8.getRandomIntegerInRange(0, 0x10FFFF + 1);\n      } while (randomCodePoint >= 0xD800 && randomCodePoint <= 0xDFFF);\n\n      randomString += LZUTF8.Encoding.CodePoint.decodeToString(randomCodePoint);\n    }\n\n    return randomString;\n  };\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var StringBuilder = function () {\n    function StringBuilder(outputBufferCapacity) {\n      if (outputBufferCapacity === void 0) {\n        outputBufferCapacity = 1024;\n      }\n\n      this.outputBufferCapacity = outputBufferCapacity;\n      this.outputPosition = 0;\n      this.outputString = \"\";\n      this.outputBuffer = new Uint16Array(this.outputBufferCapacity);\n    }\n\n    StringBuilder.prototype.appendCharCode = function (charCode) {\n      this.outputBuffer[this.outputPosition++] = charCode;\n      if (this.outputPosition === this.outputBufferCapacity) this.flushBufferToOutputString();\n    };\n\n    StringBuilder.prototype.appendCharCodes = function (charCodes) {\n      for (var i = 0, length_1 = charCodes.length; i < length_1; i++) this.appendCharCode(charCodes[i]);\n    };\n\n    StringBuilder.prototype.appendString = function (str) {\n      for (var i = 0, length_2 = str.length; i < length_2; i++) this.appendCharCode(str.charCodeAt(i));\n    };\n\n    StringBuilder.prototype.appendCodePoint = function (codePoint) {\n      if (codePoint <= 0xFFFF) {\n        this.appendCharCode(codePoint);\n      } else if (codePoint <= 0x10FFFF) {\n        this.appendCharCode(0xD800 + (codePoint - 0x10000 >>> 10));\n        this.appendCharCode(0xDC00 + (codePoint - 0x10000 & 1023));\n      } else throw new Error(\"appendCodePoint: A code point of \".concat(codePoint, \" cannot be encoded in UTF-16\"));\n    };\n\n    StringBuilder.prototype.getOutputString = function () {\n      this.flushBufferToOutputString();\n      return this.outputString;\n    };\n\n    StringBuilder.prototype.flushBufferToOutputString = function () {\n      if (this.outputPosition === this.outputBufferCapacity) this.outputString += String.fromCharCode.apply(null, this.outputBuffer);else this.outputString += String.fromCharCode.apply(null, this.outputBuffer.subarray(0, this.outputPosition));\n      this.outputPosition = 0;\n    };\n\n    return StringBuilder;\n  }();\n\n  LZUTF8.StringBuilder = StringBuilder;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Timer = function () {\n    function Timer() {\n      this.restart();\n    }\n\n    Timer.prototype.restart = function () {\n      this.startTime = Timer.getTimestamp();\n    };\n\n    Timer.prototype.getElapsedTime = function () {\n      return Timer.getTimestamp() - this.startTime;\n    };\n\n    Timer.prototype.getElapsedTimeAndRestart = function () {\n      var elapsedTime = this.getElapsedTime();\n      this.restart();\n      return elapsedTime;\n    };\n\n    Timer.prototype.logAndRestart = function (title, logToDocument) {\n      if (logToDocument === void 0) {\n        logToDocument = true;\n      }\n\n      var elapsedTime = this.getElapsedTime();\n      var message = \"\".concat(title, \": \").concat(elapsedTime.toFixed(3), \"ms\");\n      LZUTF8.log(message, logToDocument);\n      this.restart();\n      return elapsedTime;\n    };\n\n    Timer.getTimestamp = function () {\n      if (!this.timestampFunc) this.createGlobalTimestampFunction();\n      return this.timestampFunc();\n    };\n\n    Timer.getMicrosecondTimestamp = function () {\n      return Math.floor(Timer.getTimestamp() * 1000);\n    };\n\n    Timer.createGlobalTimestampFunction = function () {\n      if (typeof process === \"object\" && typeof process.hrtime === \"function\") {\n        var baseTimestamp_1 = 0;\n\n        this.timestampFunc = function () {\n          var nodeTimeStamp = process.hrtime();\n          var millisecondTime = nodeTimeStamp[0] * 1000 + nodeTimeStamp[1] / 1000000;\n          return baseTimestamp_1 + millisecondTime;\n        };\n\n        baseTimestamp_1 = Date.now() - this.timestampFunc();\n      } else if (typeof chrome === \"object\" && chrome.Interval) {\n        var baseTimestamp_2 = Date.now();\n        var chromeIntervalObject_1 = new chrome.Interval();\n        chromeIntervalObject_1.start();\n\n        this.timestampFunc = function () {\n          return baseTimestamp_2 + chromeIntervalObject_1.microseconds() / 1000;\n        };\n      } else if (typeof performance === \"object\" && performance.now) {\n        var baseTimestamp_3 = Date.now() - performance.now();\n\n        this.timestampFunc = function () {\n          return baseTimestamp_3 + performance.now();\n        };\n      } else if (Date.now) {\n        this.timestampFunc = function () {\n          return Date.now();\n        };\n      } else {\n        this.timestampFunc = function () {\n          return new Date().getTime();\n        };\n      }\n    };\n\n    return Timer;\n  }();\n\n  LZUTF8.Timer = Timer;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Compressor = function () {\n    function Compressor(useCustomHashTable) {\n      if (useCustomHashTable === void 0) {\n        useCustomHashTable = true;\n      }\n\n      this.MinimumSequenceLength = 4;\n      this.MaximumSequenceLength = 31;\n      this.MaximumMatchDistance = 32767;\n      this.PrefixHashTableSize = 65537;\n      this.inputBufferStreamOffset = 1;\n      if (useCustomHashTable && typeof Uint32Array == \"function\") this.prefixHashTable = new LZUTF8.CompressorCustomHashTable(this.PrefixHashTableSize);else this.prefixHashTable = new LZUTF8.CompressorSimpleHashTable(this.PrefixHashTableSize);\n    }\n\n    Compressor.prototype.compressBlock = function (input) {\n      if (input === undefined || input === null) throw new TypeError(\"compressBlock: undefined or null input received\");\n      if (typeof input == \"string\") input = LZUTF8.encodeUTF8(input);\n      input = LZUTF8.BufferTools.convertToUint8ArrayIfNeeded(input);\n      return this.compressUtf8Block(input);\n    };\n\n    Compressor.prototype.compressUtf8Block = function (utf8Bytes) {\n      if (!utf8Bytes || utf8Bytes.length == 0) return new Uint8Array(0);\n      var bufferStartingReadOffset = this.cropAndAddNewBytesToInputBuffer(utf8Bytes);\n      var inputBuffer = this.inputBuffer;\n      var inputBufferLength = this.inputBuffer.length;\n      this.outputBuffer = new Uint8Array(utf8Bytes.length);\n      this.outputBufferPosition = 0;\n      var latestMatchEndPosition = 0;\n\n      for (var readPosition = bufferStartingReadOffset; readPosition < inputBufferLength; readPosition++) {\n        var inputValue = inputBuffer[readPosition];\n        var withinAMatchedRange = readPosition < latestMatchEndPosition;\n\n        if (readPosition > inputBufferLength - this.MinimumSequenceLength) {\n          if (!withinAMatchedRange) this.outputRawByte(inputValue);\n          continue;\n        }\n\n        var targetBucketIndex = this.getBucketIndexForPrefix(readPosition);\n\n        if (!withinAMatchedRange) {\n          var matchLocator = this.findLongestMatch(readPosition, targetBucketIndex);\n\n          if (matchLocator != null) {\n            this.outputPointerBytes(matchLocator.length, matchLocator.distance);\n            latestMatchEndPosition = readPosition + matchLocator.length;\n            withinAMatchedRange = true;\n          }\n        }\n\n        if (!withinAMatchedRange) this.outputRawByte(inputValue);\n        var inputStreamPosition = this.inputBufferStreamOffset + readPosition;\n        this.prefixHashTable.addValueToBucket(targetBucketIndex, inputStreamPosition);\n      }\n\n      return this.outputBuffer.subarray(0, this.outputBufferPosition);\n    };\n\n    Compressor.prototype.findLongestMatch = function (matchedSequencePosition, bucketIndex) {\n      var bucket = this.prefixHashTable.getArraySegmentForBucketIndex(bucketIndex, this.reusableArraySegmentObject);\n      if (bucket == null) return null;\n      var input = this.inputBuffer;\n      var longestMatchDistance;\n      var longestMatchLength = 0;\n\n      for (var i = 0; i < bucket.length; i++) {\n        var testedSequencePosition = bucket.getInReversedOrder(i) - this.inputBufferStreamOffset;\n        var testedSequenceDistance = matchedSequencePosition - testedSequencePosition;\n        var lengthToSurpass = void 0;\n        if (longestMatchDistance === undefined) lengthToSurpass = this.MinimumSequenceLength - 1;else if (longestMatchDistance < 128 && testedSequenceDistance >= 128) lengthToSurpass = longestMatchLength + (longestMatchLength >>> 1);else lengthToSurpass = longestMatchLength;\n        if (testedSequenceDistance > this.MaximumMatchDistance || lengthToSurpass >= this.MaximumSequenceLength || matchedSequencePosition + lengthToSurpass >= input.length) break;\n        if (input[testedSequencePosition + lengthToSurpass] !== input[matchedSequencePosition + lengthToSurpass]) continue;\n\n        for (var offset = 0;; offset++) {\n          if (matchedSequencePosition + offset === input.length || input[testedSequencePosition + offset] !== input[matchedSequencePosition + offset]) {\n            if (offset > lengthToSurpass) {\n              longestMatchDistance = testedSequenceDistance;\n              longestMatchLength = offset;\n            }\n\n            break;\n          } else if (offset === this.MaximumSequenceLength) return {\n            distance: testedSequenceDistance,\n            length: this.MaximumSequenceLength\n          };\n        }\n      }\n\n      if (longestMatchDistance !== undefined) return {\n        distance: longestMatchDistance,\n        length: longestMatchLength\n      };else return null;\n    };\n\n    Compressor.prototype.getBucketIndexForPrefix = function (startPosition) {\n      return (this.inputBuffer[startPosition] * 7880599 + this.inputBuffer[startPosition + 1] * 39601 + this.inputBuffer[startPosition + 2] * 199 + this.inputBuffer[startPosition + 3]) % this.PrefixHashTableSize;\n    };\n\n    Compressor.prototype.outputPointerBytes = function (length, distance) {\n      if (distance < 128) {\n        this.outputRawByte(192 | length);\n        this.outputRawByte(distance);\n      } else {\n        this.outputRawByte(224 | length);\n        this.outputRawByte(distance >>> 8);\n        this.outputRawByte(distance & 255);\n      }\n    };\n\n    Compressor.prototype.outputRawByte = function (value) {\n      this.outputBuffer[this.outputBufferPosition++] = value;\n    };\n\n    Compressor.prototype.cropAndAddNewBytesToInputBuffer = function (newInput) {\n      if (this.inputBuffer === undefined) {\n        this.inputBuffer = newInput;\n        return 0;\n      } else {\n        var cropLength = Math.min(this.inputBuffer.length, this.MaximumMatchDistance);\n        var cropStartOffset = this.inputBuffer.length - cropLength;\n        this.inputBuffer = LZUTF8.CompressionCommon.getCroppedAndAppendedByteArray(this.inputBuffer, cropStartOffset, cropLength, newInput);\n        this.inputBufferStreamOffset += cropStartOffset;\n        return cropLength;\n      }\n    };\n\n    return Compressor;\n  }();\n\n  LZUTF8.Compressor = Compressor;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var CompressorCustomHashTable = function () {\n    function CompressorCustomHashTable(bucketCount) {\n      this.minimumBucketCapacity = 4;\n      this.maximumBucketCapacity = 64;\n      this.bucketLocators = new Uint32Array(bucketCount * 2);\n      this.storage = new Uint32Array(bucketCount * 2);\n      this.storageIndex = 1;\n    }\n\n    CompressorCustomHashTable.prototype.addValueToBucket = function (bucketIndex, valueToAdd) {\n      bucketIndex <<= 1;\n      if (this.storageIndex >= this.storage.length >>> 1) this.compact();\n      var startPosition = this.bucketLocators[bucketIndex];\n      var length;\n\n      if (startPosition === 0) {\n        startPosition = this.storageIndex;\n        length = 1;\n        this.storage[this.storageIndex] = valueToAdd;\n        this.storageIndex += this.minimumBucketCapacity;\n      } else {\n        length = this.bucketLocators[bucketIndex + 1];\n        if (length === this.maximumBucketCapacity - 1) length = this.truncateBucketToNewerElements(startPosition, length, this.maximumBucketCapacity / 2);\n        var endPosition = startPosition + length;\n\n        if (this.storage[endPosition] === 0) {\n          this.storage[endPosition] = valueToAdd;\n          if (endPosition === this.storageIndex) this.storageIndex += length;\n        } else {\n          LZUTF8.ArrayTools.copyElements(this.storage, startPosition, this.storage, this.storageIndex, length);\n          startPosition = this.storageIndex;\n          this.storageIndex += length;\n          this.storage[this.storageIndex++] = valueToAdd;\n          this.storageIndex += length;\n        }\n\n        length++;\n      }\n\n      this.bucketLocators[bucketIndex] = startPosition;\n      this.bucketLocators[bucketIndex + 1] = length;\n    };\n\n    CompressorCustomHashTable.prototype.truncateBucketToNewerElements = function (startPosition, bucketLength, truncatedBucketLength) {\n      var sourcePosition = startPosition + bucketLength - truncatedBucketLength;\n      LZUTF8.ArrayTools.copyElements(this.storage, sourcePosition, this.storage, startPosition, truncatedBucketLength);\n      LZUTF8.ArrayTools.zeroElements(this.storage, startPosition + truncatedBucketLength, bucketLength - truncatedBucketLength);\n      return truncatedBucketLength;\n    };\n\n    CompressorCustomHashTable.prototype.compact = function () {\n      var oldBucketLocators = this.bucketLocators;\n      var oldStorage = this.storage;\n      this.bucketLocators = new Uint32Array(this.bucketLocators.length);\n      this.storageIndex = 1;\n\n      for (var bucketIndex = 0; bucketIndex < oldBucketLocators.length; bucketIndex += 2) {\n        var length_3 = oldBucketLocators[bucketIndex + 1];\n        if (length_3 === 0) continue;\n        this.bucketLocators[bucketIndex] = this.storageIndex;\n        this.bucketLocators[bucketIndex + 1] = length_3;\n        this.storageIndex += Math.max(Math.min(length_3 * 2, this.maximumBucketCapacity), this.minimumBucketCapacity);\n      }\n\n      this.storage = new Uint32Array(this.storageIndex * 8);\n\n      for (var bucketIndex = 0; bucketIndex < oldBucketLocators.length; bucketIndex += 2) {\n        var sourcePosition = oldBucketLocators[bucketIndex];\n        if (sourcePosition === 0) continue;\n        var destPosition = this.bucketLocators[bucketIndex];\n        var length_4 = this.bucketLocators[bucketIndex + 1];\n        LZUTF8.ArrayTools.copyElements(oldStorage, sourcePosition, this.storage, destPosition, length_4);\n      }\n    };\n\n    CompressorCustomHashTable.prototype.getArraySegmentForBucketIndex = function (bucketIndex, outputObject) {\n      bucketIndex <<= 1;\n      var startPosition = this.bucketLocators[bucketIndex];\n      if (startPosition === 0) return null;\n      if (outputObject === undefined) outputObject = new LZUTF8.ArraySegment(this.storage, startPosition, this.bucketLocators[bucketIndex + 1]);\n      return outputObject;\n    };\n\n    CompressorCustomHashTable.prototype.getUsedBucketCount = function () {\n      return Math.floor(LZUTF8.ArrayTools.countNonzeroValuesInArray(this.bucketLocators) / 2);\n    };\n\n    CompressorCustomHashTable.prototype.getTotalElementCount = function () {\n      var result = 0;\n\n      for (var i = 0; i < this.bucketLocators.length; i += 2) result += this.bucketLocators[i + 1];\n\n      return result;\n    };\n\n    return CompressorCustomHashTable;\n  }();\n\n  LZUTF8.CompressorCustomHashTable = CompressorCustomHashTable;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var CompressorSimpleHashTable = function () {\n    function CompressorSimpleHashTable(size) {\n      this.maximumBucketCapacity = 64;\n      this.buckets = new Array(size);\n    }\n\n    CompressorSimpleHashTable.prototype.addValueToBucket = function (bucketIndex, valueToAdd) {\n      var bucket = this.buckets[bucketIndex];\n\n      if (bucket === undefined) {\n        this.buckets[bucketIndex] = [valueToAdd];\n      } else {\n        if (bucket.length === this.maximumBucketCapacity - 1) LZUTF8.ArrayTools.truncateStartingElements(bucket, this.maximumBucketCapacity / 2);\n        bucket.push(valueToAdd);\n      }\n    };\n\n    CompressorSimpleHashTable.prototype.getArraySegmentForBucketIndex = function (bucketIndex, outputObject) {\n      var bucket = this.buckets[bucketIndex];\n      if (bucket === undefined) return null;\n      if (outputObject === undefined) outputObject = new LZUTF8.ArraySegment(bucket, 0, bucket.length);\n      return outputObject;\n    };\n\n    CompressorSimpleHashTable.prototype.getUsedBucketCount = function () {\n      return LZUTF8.ArrayTools.countNonzeroValuesInArray(this.buckets);\n    };\n\n    CompressorSimpleHashTable.prototype.getTotalElementCount = function () {\n      var currentSum = 0;\n\n      for (var i = 0; i < this.buckets.length; i++) {\n        if (this.buckets[i] !== undefined) currentSum += this.buckets[i].length;\n      }\n\n      return currentSum;\n    };\n\n    return CompressorSimpleHashTable;\n  }();\n\n  LZUTF8.CompressorSimpleHashTable = CompressorSimpleHashTable;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Decompressor = function () {\n    function Decompressor() {\n      this.MaximumMatchDistance = 32767;\n      this.outputPosition = 0;\n    }\n\n    Decompressor.prototype.decompressBlockToString = function (input) {\n      input = LZUTF8.BufferTools.convertToUint8ArrayIfNeeded(input);\n      return LZUTF8.decodeUTF8(this.decompressBlock(input));\n    };\n\n    Decompressor.prototype.decompressBlock = function (input) {\n      if (this.inputBufferRemainder) {\n        input = LZUTF8.ArrayTools.concatUint8Arrays([this.inputBufferRemainder, input]);\n        this.inputBufferRemainder = undefined;\n      }\n\n      var outputStartPosition = this.cropOutputBufferToWindowAndInitialize(Math.max(input.length * 4, 1024));\n\n      for (var readPosition = 0, inputLength = input.length; readPosition < inputLength; readPosition++) {\n        var inputValue = input[readPosition];\n\n        if (inputValue >>> 6 != 3) {\n          this.outputByte(inputValue);\n          continue;\n        }\n\n        var sequenceLengthIdentifier = inputValue >>> 5;\n\n        if (readPosition == inputLength - 1 || readPosition == inputLength - 2 && sequenceLengthIdentifier == 7) {\n          this.inputBufferRemainder = input.subarray(readPosition);\n          break;\n        }\n\n        if (input[readPosition + 1] >>> 7 === 1) {\n          this.outputByte(inputValue);\n        } else {\n          var matchLength = inputValue & 31;\n          var matchDistance = void 0;\n\n          if (sequenceLengthIdentifier == 6) {\n            matchDistance = input[readPosition + 1];\n            readPosition += 1;\n          } else {\n            matchDistance = input[readPosition + 1] << 8 | input[readPosition + 2];\n            readPosition += 2;\n          }\n\n          var matchPosition = this.outputPosition - matchDistance;\n\n          for (var offset = 0; offset < matchLength; offset++) this.outputByte(this.outputBuffer[matchPosition + offset]);\n        }\n      }\n\n      this.rollBackIfOutputBufferEndsWithATruncatedMultibyteSequence();\n      return LZUTF8.CompressionCommon.getCroppedBuffer(this.outputBuffer, outputStartPosition, this.outputPosition - outputStartPosition);\n    };\n\n    Decompressor.prototype.outputByte = function (value) {\n      if (this.outputPosition === this.outputBuffer.length) this.outputBuffer = LZUTF8.ArrayTools.doubleByteArrayCapacity(this.outputBuffer);\n      this.outputBuffer[this.outputPosition++] = value;\n    };\n\n    Decompressor.prototype.cropOutputBufferToWindowAndInitialize = function (initialCapacity) {\n      if (!this.outputBuffer) {\n        this.outputBuffer = new Uint8Array(initialCapacity);\n        return 0;\n      }\n\n      var cropLength = Math.min(this.outputPosition, this.MaximumMatchDistance);\n      this.outputBuffer = LZUTF8.CompressionCommon.getCroppedBuffer(this.outputBuffer, this.outputPosition - cropLength, cropLength, initialCapacity);\n      this.outputPosition = cropLength;\n\n      if (this.outputBufferRemainder) {\n        for (var i = 0; i < this.outputBufferRemainder.length; i++) this.outputByte(this.outputBufferRemainder[i]);\n\n        this.outputBufferRemainder = undefined;\n      }\n\n      return cropLength;\n    };\n\n    Decompressor.prototype.rollBackIfOutputBufferEndsWithATruncatedMultibyteSequence = function () {\n      for (var offset = 1; offset <= 4 && this.outputPosition - offset >= 0; offset++) {\n        var value = this.outputBuffer[this.outputPosition - offset];\n\n        if (offset < 4 && value >>> 3 === 30 || offset < 3 && value >>> 4 === 14 || offset < 2 && value >>> 5 === 6) {\n          this.outputBufferRemainder = this.outputBuffer.subarray(this.outputPosition - offset, this.outputPosition);\n          this.outputPosition -= offset;\n          return;\n        }\n      }\n    };\n\n    return Decompressor;\n  }();\n\n  LZUTF8.Decompressor = Decompressor;\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Encoding;\n\n  (function (Encoding) {\n    var Base64;\n\n    (function (Base64) {\n      var charCodeMap = new Uint8Array([65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47]);\n      var reverseCharCodeMap = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 255, 255, 255, 255]);\n      var paddingCharacter = \"=\";\n      var paddingCharCode = 61;\n\n      Base64.encode = function (inputBytes) {\n        if (!inputBytes || inputBytes.length == 0) return \"\";\n\n        if (LZUTF8.runningInNodeJS()) {\n          return LZUTF8.BufferTools.uint8ArrayToBuffer(inputBytes).toString(\"base64\");\n        } else {\n          return Base64.encodeWithJS(inputBytes);\n        }\n      };\n\n      Base64.decode = function (base64String) {\n        if (!base64String) return new Uint8Array(0);\n\n        if (LZUTF8.runningInNodeJS()) {\n          return LZUTF8.BufferTools.bufferToUint8Array(Buffer.from(base64String, \"base64\"));\n        } else {\n          return Base64.decodeWithJS(base64String);\n        }\n      };\n\n      Base64.encodeWithJS = function (inputBytes, addPadding) {\n        if (addPadding === void 0) {\n          addPadding = true;\n        }\n\n        if (!inputBytes || inputBytes.length == 0) return \"\";\n        var map = charCodeMap;\n        var output = new LZUTF8.StringBuilder();\n        var uint24;\n\n        for (var readPosition = 0, length_5 = inputBytes.length; readPosition < length_5; readPosition += 3) {\n          if (readPosition <= length_5 - 3) {\n            uint24 = inputBytes[readPosition] << 16 | inputBytes[readPosition + 1] << 8 | inputBytes[readPosition + 2];\n            output.appendCharCode(map[uint24 >>> 18 & 63]);\n            output.appendCharCode(map[uint24 >>> 12 & 63]);\n            output.appendCharCode(map[uint24 >>> 6 & 63]);\n            output.appendCharCode(map[uint24 & 63]);\n            uint24 = 0;\n          } else if (readPosition === length_5 - 2) {\n            uint24 = inputBytes[readPosition] << 16 | inputBytes[readPosition + 1] << 8;\n            output.appendCharCode(map[uint24 >>> 18 & 63]);\n            output.appendCharCode(map[uint24 >>> 12 & 63]);\n            output.appendCharCode(map[uint24 >>> 6 & 63]);\n            if (addPadding) output.appendCharCode(paddingCharCode);\n          } else if (readPosition === length_5 - 1) {\n            uint24 = inputBytes[readPosition] << 16;\n            output.appendCharCode(map[uint24 >>> 18 & 63]);\n            output.appendCharCode(map[uint24 >>> 12 & 63]);\n\n            if (addPadding) {\n              output.appendCharCode(paddingCharCode);\n              output.appendCharCode(paddingCharCode);\n            }\n          }\n        }\n\n        return output.getOutputString();\n      };\n\n      Base64.decodeWithJS = function (base64String, outputBuffer) {\n        if (!base64String || base64String.length == 0) return new Uint8Array(0);\n        var lengthModulo4 = base64String.length % 4;\n        if (lengthModulo4 === 1) throw new Error(\"Invalid Base64 string: length % 4 == 1\");else if (lengthModulo4 === 2) base64String += paddingCharacter + paddingCharacter;else if (lengthModulo4 === 3) base64String += paddingCharacter;\n        if (!outputBuffer) outputBuffer = new Uint8Array(base64String.length);\n        var outputPosition = 0;\n        var length = base64String.length;\n\n        for (var i = 0; i < length; i += 4) {\n          var uint24 = reverseCharCodeMap[base64String.charCodeAt(i)] << 18 | reverseCharCodeMap[base64String.charCodeAt(i + 1)] << 12 | reverseCharCodeMap[base64String.charCodeAt(i + 2)] << 6 | reverseCharCodeMap[base64String.charCodeAt(i + 3)];\n          outputBuffer[outputPosition++] = uint24 >>> 16 & 255;\n          outputBuffer[outputPosition++] = uint24 >>> 8 & 255;\n          outputBuffer[outputPosition++] = uint24 & 255;\n        }\n\n        if (base64String.charCodeAt(length - 1) == paddingCharCode) outputPosition--;\n        if (base64String.charCodeAt(length - 2) == paddingCharCode) outputPosition--;\n        return outputBuffer.subarray(0, outputPosition);\n      };\n    })(Base64 = Encoding.Base64 || (Encoding.Base64 = {}));\n  })(Encoding = LZUTF8.Encoding || (LZUTF8.Encoding = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Encoding;\n\n  (function (Encoding) {\n    var BinaryString;\n\n    (function (BinaryString) {\n      BinaryString.encode = function (input) {\n        if (input == null) throw new TypeError(\"BinaryString.encode: undefined or null input received\");\n        if (input.length === 0) return \"\";\n        var inputLength = input.length;\n        var outputStringBuilder = new LZUTF8.StringBuilder();\n        var remainder = 0;\n        var state = 1;\n\n        for (var i = 0; i < inputLength; i += 2) {\n          var value = void 0;\n          if (i == inputLength - 1) value = input[i] << 8;else value = input[i] << 8 | input[i + 1];\n          outputStringBuilder.appendCharCode(remainder << 16 - state | value >>> state);\n          remainder = value & (1 << state) - 1;\n\n          if (state === 15) {\n            outputStringBuilder.appendCharCode(remainder);\n            remainder = 0;\n            state = 1;\n          } else {\n            state += 1;\n          }\n\n          if (i >= inputLength - 2) outputStringBuilder.appendCharCode(remainder << 16 - state);\n        }\n\n        outputStringBuilder.appendCharCode(32768 | inputLength % 2);\n        return outputStringBuilder.getOutputString();\n      };\n\n      BinaryString.decode = function (input) {\n        if (typeof input !== \"string\") throw new TypeError(\"BinaryString.decode: invalid input type\");\n        if (input == \"\") return new Uint8Array(0);\n        var output = new Uint8Array(input.length * 3);\n        var outputPosition = 0;\n\n        var appendToOutput = function (value) {\n          output[outputPosition++] = value >>> 8;\n          output[outputPosition++] = value & 255;\n        };\n\n        var remainder = 0;\n        var state = 0;\n\n        for (var i = 0; i < input.length; i++) {\n          var value = input.charCodeAt(i);\n\n          if (value >= 32768) {\n            if (value == (32768 | 1)) outputPosition--;\n            state = 0;\n            continue;\n          }\n\n          if (state == 0) {\n            remainder = value;\n          } else {\n            appendToOutput(remainder << state | value >>> 15 - state);\n            remainder = value & (1 << 15 - state) - 1;\n          }\n\n          if (state == 15) state = 0;else state += 1;\n        }\n\n        return output.subarray(0, outputPosition);\n      };\n    })(BinaryString = Encoding.BinaryString || (Encoding.BinaryString = {}));\n  })(Encoding = LZUTF8.Encoding || (LZUTF8.Encoding = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Encoding;\n\n  (function (Encoding) {\n    var CodePoint;\n\n    (function (CodePoint) {\n      CodePoint.encodeFromString = function (str, position) {\n        var charCode = str.charCodeAt(position);\n        if (charCode < 0xD800 || charCode > 0xDBFF) return charCode;else {\n          var nextCharCode = str.charCodeAt(position + 1);\n          if (nextCharCode >= 0xDC00 && nextCharCode <= 0xDFFF) return 0x10000 + ((charCode - 0xD800 << 10) + (nextCharCode - 0xDC00));else throw new Error(\"getUnicodeCodePoint: Received a lead surrogate character, char code \".concat(charCode, \", followed by \").concat(nextCharCode, \", which is not a trailing surrogate character code.\"));\n        }\n      };\n\n      CodePoint.decodeToString = function (codePoint) {\n        if (codePoint <= 0xFFFF) return String.fromCharCode(codePoint);else if (codePoint <= 0x10FFFF) return String.fromCharCode(0xD800 + (codePoint - 0x10000 >>> 10), 0xDC00 + (codePoint - 0x10000 & 1023));else throw new Error(\"getStringFromUnicodeCodePoint: A code point of \".concat(codePoint, \" cannot be encoded in UTF-16\"));\n      };\n    })(CodePoint = Encoding.CodePoint || (Encoding.CodePoint = {}));\n  })(Encoding = LZUTF8.Encoding || (LZUTF8.Encoding = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Encoding;\n\n  (function (Encoding) {\n    var DecimalString;\n\n    (function (DecimalString) {\n      var lookupTable = [\"000\", \"001\", \"002\", \"003\", \"004\", \"005\", \"006\", \"007\", \"008\", \"009\", \"010\", \"011\", \"012\", \"013\", \"014\", \"015\", \"016\", \"017\", \"018\", \"019\", \"020\", \"021\", \"022\", \"023\", \"024\", \"025\", \"026\", \"027\", \"028\", \"029\", \"030\", \"031\", \"032\", \"033\", \"034\", \"035\", \"036\", \"037\", \"038\", \"039\", \"040\", \"041\", \"042\", \"043\", \"044\", \"045\", \"046\", \"047\", \"048\", \"049\", \"050\", \"051\", \"052\", \"053\", \"054\", \"055\", \"056\", \"057\", \"058\", \"059\", \"060\", \"061\", \"062\", \"063\", \"064\", \"065\", \"066\", \"067\", \"068\", \"069\", \"070\", \"071\", \"072\", \"073\", \"074\", \"075\", \"076\", \"077\", \"078\", \"079\", \"080\", \"081\", \"082\", \"083\", \"084\", \"085\", \"086\", \"087\", \"088\", \"089\", \"090\", \"091\", \"092\", \"093\", \"094\", \"095\", \"096\", \"097\", \"098\", \"099\", \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \"107\", \"108\", \"109\", \"110\", \"111\", \"112\", \"113\", \"114\", \"115\", \"116\", \"117\", \"118\", \"119\", \"120\", \"121\", \"122\", \"123\", \"124\", \"125\", \"126\", \"127\", \"128\", \"129\", \"130\", \"131\", \"132\", \"133\", \"134\", \"135\", \"136\", \"137\", \"138\", \"139\", \"140\", \"141\", \"142\", \"143\", \"144\", \"145\", \"146\", \"147\", \"148\", \"149\", \"150\", \"151\", \"152\", \"153\", \"154\", \"155\", \"156\", \"157\", \"158\", \"159\", \"160\", \"161\", \"162\", \"163\", \"164\", \"165\", \"166\", \"167\", \"168\", \"169\", \"170\", \"171\", \"172\", \"173\", \"174\", \"175\", \"176\", \"177\", \"178\", \"179\", \"180\", \"181\", \"182\", \"183\", \"184\", \"185\", \"186\", \"187\", \"188\", \"189\", \"190\", \"191\", \"192\", \"193\", \"194\", \"195\", \"196\", \"197\", \"198\", \"199\", \"200\", \"201\", \"202\", \"203\", \"204\", \"205\", \"206\", \"207\", \"208\", \"209\", \"210\", \"211\", \"212\", \"213\", \"214\", \"215\", \"216\", \"217\", \"218\", \"219\", \"220\", \"221\", \"222\", \"223\", \"224\", \"225\", \"226\", \"227\", \"228\", \"229\", \"230\", \"231\", \"232\", \"233\", \"234\", \"235\", \"236\", \"237\", \"238\", \"239\", \"240\", \"241\", \"242\", \"243\", \"244\", \"245\", \"246\", \"247\", \"248\", \"249\", \"250\", \"251\", \"252\", \"253\", \"254\", \"255\"];\n\n      DecimalString.encode = function (binaryBytes) {\n        var resultArray = [];\n\n        for (var i = 0; i < binaryBytes.length; i++) resultArray.push(lookupTable[binaryBytes[i]]);\n\n        return resultArray.join(\" \");\n      };\n    })(DecimalString = Encoding.DecimalString || (Encoding.DecimalString = {}));\n  })(Encoding = LZUTF8.Encoding || (LZUTF8.Encoding = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Encoding;\n\n  (function (Encoding) {\n    var StorageBinaryString;\n\n    (function (StorageBinaryString) {\n      StorageBinaryString.encode = function (input) {\n        return Encoding.BinaryString.encode(input).replace(/\\0/g, '\\u8002');\n      };\n\n      StorageBinaryString.decode = function (input) {\n        return Encoding.BinaryString.decode(input.replace(/\\u8002/g, '\\0'));\n      };\n    })(StorageBinaryString = Encoding.StorageBinaryString || (Encoding.StorageBinaryString = {}));\n  })(Encoding = LZUTF8.Encoding || (LZUTF8.Encoding = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  var Encoding;\n\n  (function (Encoding) {\n    var UTF8;\n\n    (function (UTF8) {\n      var nativeTextEncoder;\n      var nativeTextDecoder;\n\n      UTF8.encode = function (str) {\n        if (!str || str.length == 0) return new Uint8Array(0);\n\n        if (LZUTF8.runningInNodeJS()) {\n          return LZUTF8.BufferTools.bufferToUint8Array(Buffer.from(str, \"utf8\"));\n        } else if (UTF8.createNativeTextEncoderAndDecoderIfAvailable()) {\n          return nativeTextEncoder.encode(str);\n        } else {\n          return UTF8.encodeWithJS(str);\n        }\n      };\n\n      UTF8.decode = function (utf8Bytes) {\n        if (!utf8Bytes || utf8Bytes.length == 0) return \"\";\n\n        if (LZUTF8.runningInNodeJS()) {\n          return LZUTF8.BufferTools.uint8ArrayToBuffer(utf8Bytes).toString(\"utf8\");\n        } else if (UTF8.createNativeTextEncoderAndDecoderIfAvailable()) {\n          return nativeTextDecoder.decode(utf8Bytes);\n        } else {\n          return UTF8.decodeWithJS(utf8Bytes);\n        }\n      };\n\n      UTF8.encodeWithJS = function (str, outputArray) {\n        if (!str || str.length == 0) return new Uint8Array(0);\n        if (!outputArray) outputArray = new Uint8Array(str.length * 4);\n        var writeIndex = 0;\n\n        for (var readIndex = 0; readIndex < str.length; readIndex++) {\n          var charCode = Encoding.CodePoint.encodeFromString(str, readIndex);\n\n          if (charCode <= 0x7F) {\n            outputArray[writeIndex++] = charCode;\n          } else if (charCode <= 0x7FF) {\n            outputArray[writeIndex++] = 0xC0 | charCode >>> 6;\n            outputArray[writeIndex++] = 0x80 | charCode & 63;\n          } else if (charCode <= 0xFFFF) {\n            outputArray[writeIndex++] = 0xE0 | charCode >>> 12;\n            outputArray[writeIndex++] = 0x80 | charCode >>> 6 & 63;\n            outputArray[writeIndex++] = 0x80 | charCode & 63;\n          } else if (charCode <= 0x10FFFF) {\n            outputArray[writeIndex++] = 0xF0 | charCode >>> 18;\n            outputArray[writeIndex++] = 0x80 | charCode >>> 12 & 63;\n            outputArray[writeIndex++] = 0x80 | charCode >>> 6 & 63;\n            outputArray[writeIndex++] = 0x80 | charCode & 63;\n            readIndex++;\n          } else throw new Error(\"Invalid UTF-16 string: Encountered a character unsupported by UTF-8/16 (RFC 3629)\");\n        }\n\n        return outputArray.subarray(0, writeIndex);\n      };\n\n      UTF8.decodeWithJS = function (utf8Bytes, startOffset, endOffset) {\n        if (startOffset === void 0) {\n          startOffset = 0;\n        }\n\n        if (!utf8Bytes || utf8Bytes.length == 0) return \"\";\n        if (endOffset === undefined) endOffset = utf8Bytes.length;\n        var output = new LZUTF8.StringBuilder();\n        var outputCodePoint;\n        var leadByte;\n\n        for (var readIndex = startOffset, length_6 = endOffset; readIndex < length_6;) {\n          leadByte = utf8Bytes[readIndex];\n\n          if (leadByte >>> 7 === 0) {\n            outputCodePoint = leadByte;\n            readIndex += 1;\n          } else if (leadByte >>> 5 === 6) {\n            if (readIndex + 1 >= endOffset) throw new Error(\"Invalid UTF-8 stream: Truncated codepoint sequence encountered at position \" + readIndex);\n            outputCodePoint = (leadByte & 31) << 6 | utf8Bytes[readIndex + 1] & 63;\n            readIndex += 2;\n          } else if (leadByte >>> 4 === 14) {\n            if (readIndex + 2 >= endOffset) throw new Error(\"Invalid UTF-8 stream: Truncated codepoint sequence encountered at position \" + readIndex);\n            outputCodePoint = (leadByte & 15) << 12 | (utf8Bytes[readIndex + 1] & 63) << 6 | utf8Bytes[readIndex + 2] & 63;\n            readIndex += 3;\n          } else if (leadByte >>> 3 === 30) {\n            if (readIndex + 3 >= endOffset) throw new Error(\"Invalid UTF-8 stream: Truncated codepoint sequence encountered at position \" + readIndex);\n            outputCodePoint = (leadByte & 7) << 18 | (utf8Bytes[readIndex + 1] & 63) << 12 | (utf8Bytes[readIndex + 2] & 63) << 6 | utf8Bytes[readIndex + 3] & 63;\n            readIndex += 4;\n          } else throw new Error(\"Invalid UTF-8 stream: An invalid lead byte value encountered at position \" + readIndex);\n\n          output.appendCodePoint(outputCodePoint);\n        }\n\n        return output.getOutputString();\n      };\n\n      UTF8.createNativeTextEncoderAndDecoderIfAvailable = function () {\n        if (nativeTextEncoder) return true;\n\n        if (typeof TextEncoder == \"function\") {\n          nativeTextEncoder = new TextEncoder(\"utf-8\");\n          nativeTextDecoder = new TextDecoder(\"utf-8\");\n          return true;\n        } else return false;\n      };\n    })(UTF8 = Encoding.UTF8 || (Encoding.UTF8 = {}));\n  })(Encoding = LZUTF8.Encoding || (LZUTF8.Encoding = {}));\n})(LZUTF8 || (LZUTF8 = {}));\n\nvar LZUTF8;\n\n(function (LZUTF8) {\n  function compress(input, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (input == null) throw new TypeError(\"compress: undefined or null input received\");\n    var inputEncoding = LZUTF8.CompressionCommon.detectCompressionSourceEncoding(input);\n    options = LZUTF8.ObjectTools.override({\n      inputEncoding: inputEncoding,\n      outputEncoding: \"ByteArray\"\n    }, options);\n    var compressor = new LZUTF8.Compressor();\n    var compressedBytes = compressor.compressBlock(input);\n    return LZUTF8.CompressionCommon.encodeCompressedBytes(compressedBytes, options.outputEncoding);\n  }\n\n  LZUTF8.compress = compress;\n\n  function decompress(input, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (input == null) throw new TypeError(\"decompress: undefined or null input received\");\n    options = LZUTF8.ObjectTools.override({\n      inputEncoding: \"ByteArray\",\n      outputEncoding: \"String\"\n    }, options);\n    var inputBytes = LZUTF8.CompressionCommon.decodeCompressedBytes(input, options.inputEncoding);\n    var decompressor = new LZUTF8.Decompressor();\n    var decompressedBytes = decompressor.decompressBlock(inputBytes);\n    return LZUTF8.CompressionCommon.encodeDecompressedBytes(decompressedBytes, options.outputEncoding);\n  }\n\n  LZUTF8.decompress = decompress;\n\n  function compressAsync(input, options, callback) {\n    if (callback == null) callback = function () {};\n    var inputEncoding;\n\n    try {\n      inputEncoding = LZUTF8.CompressionCommon.detectCompressionSourceEncoding(input);\n    } catch (e) {\n      callback(undefined, e);\n      return;\n    }\n\n    options = LZUTF8.ObjectTools.override({\n      inputEncoding: inputEncoding,\n      outputEncoding: \"ByteArray\",\n      useWebWorker: true,\n      blockSize: 65536\n    }, options);\n    LZUTF8.enqueueImmediate(function () {\n      if (options.useWebWorker && LZUTF8.WebWorker.createGlobalWorkerIfNeeded()) {\n        LZUTF8.WebWorker.compressAsync(input, options, callback);\n      } else {\n        LZUTF8.AsyncCompressor.compressAsync(input, options, callback);\n      }\n    });\n  }\n\n  LZUTF8.compressAsync = compressAsync;\n\n  function decompressAsync(input, options, callback) {\n    if (callback == null) callback = function () {};\n\n    if (input == null) {\n      callback(undefined, new TypeError(\"decompressAsync: undefined or null input received\"));\n      return;\n    }\n\n    options = LZUTF8.ObjectTools.override({\n      inputEncoding: \"ByteArray\",\n      outputEncoding: \"String\",\n      useWebWorker: true,\n      blockSize: 65536\n    }, options);\n    var normalizedInput = LZUTF8.BufferTools.convertToUint8ArrayIfNeeded(input);\n    LZUTF8.EventLoop.enqueueImmediate(function () {\n      if (options.useWebWorker && LZUTF8.WebWorker.createGlobalWorkerIfNeeded()) {\n        LZUTF8.WebWorker.decompressAsync(normalizedInput, options, callback);\n      } else {\n        LZUTF8.AsyncDecompressor.decompressAsync(input, options, callback);\n      }\n    });\n  }\n\n  LZUTF8.decompressAsync = decompressAsync;\n\n  function createCompressionStream() {\n    return LZUTF8.AsyncCompressor.createCompressionStream();\n  }\n\n  LZUTF8.createCompressionStream = createCompressionStream;\n\n  function createDecompressionStream() {\n    return LZUTF8.AsyncDecompressor.createDecompressionStream();\n  }\n\n  LZUTF8.createDecompressionStream = createDecompressionStream;\n\n  function encodeUTF8(str) {\n    return LZUTF8.Encoding.UTF8.encode(str);\n  }\n\n  LZUTF8.encodeUTF8 = encodeUTF8;\n\n  function decodeUTF8(input) {\n    return LZUTF8.Encoding.UTF8.decode(input);\n  }\n\n  LZUTF8.decodeUTF8 = decodeUTF8;\n\n  function encodeBase64(input) {\n    return LZUTF8.Encoding.Base64.encode(input);\n  }\n\n  LZUTF8.encodeBase64 = encodeBase64;\n\n  function decodeBase64(str) {\n    return LZUTF8.Encoding.Base64.decode(str);\n  }\n\n  LZUTF8.decodeBase64 = decodeBase64;\n\n  function encodeBinaryString(input) {\n    return LZUTF8.Encoding.BinaryString.encode(input);\n  }\n\n  LZUTF8.encodeBinaryString = encodeBinaryString;\n\n  function decodeBinaryString(str) {\n    return LZUTF8.Encoding.BinaryString.decode(str);\n  }\n\n  LZUTF8.decodeBinaryString = decodeBinaryString;\n\n  function encodeStorageBinaryString(input) {\n    return LZUTF8.Encoding.StorageBinaryString.encode(input);\n  }\n\n  LZUTF8.encodeStorageBinaryString = encodeStorageBinaryString;\n\n  function decodeStorageBinaryString(str) {\n    return LZUTF8.Encoding.StorageBinaryString.decode(str);\n  }\n\n  LZUTF8.decodeStorageBinaryString = decodeStorageBinaryString;\n})(LZUTF8 || (LZUTF8 = {}));","map":null,"metadata":{},"sourceType":"script"}